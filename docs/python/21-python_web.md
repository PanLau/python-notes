# 多任务版的http服务器

## 1.浏览器请求一个页面的过程
    1.浏览器发送请求xxx.html到服务器
    2.服务器对这个请求进行处理，根据请求的名字经xxx.htmal文件打开，并读取数据
    3.服务器将数据返回到浏览器中
    4.浏览器经过分析得到需要另外一些资源。例如x.png/y.css/z.js等，那么浏览器会向服务器发送获取资源文件的请求
    服务器将所有的资源都给了浏览器之后，浏览器才会显示一个漂亮的页面

## 2.多进程版本的http服务器
    哪里执行最耗费时间就把哪里改为多进程
    client_socket.close()因为子进程赋值了父进程的资源包括client_socket，所以此时父子进程中的client_socket都指向了操作系统底层中的同一个文件描述符（fd），如果主进程不close，那么当子进程close后，它对应的文件描述符不会进行close，因为父进程冲的那个client_socket依然指向这个fd，所以为了保证当子进程服务结束之后让这个链接断开，所以需要在父进程中先close一次

看山不是山，看谁不是水
看山是山
看山
----------------------------
看山是山，看水是水
看山不是山，看水不是水
看山还是山，看谁还是水

## 3.多线程版本的http服务器
    多线程不需要在创建子线程后关闭，因为子线程共享资源

## 4.gevent版本的http服务器
    gevent.spawn(service_client, client_socket)创建这个对象之后，gevent就知道了当遇到耗费时间的时候恶意切换到这个对象指定的函数中运行

## 5.单进程-单线程并发服务器模型
    创建套接字
    绑定套接字
    监听套接字
    s_socket.setblocking(Flase) # 变为非堵塞
    while True：
        c_socket, c_addr = s_socket.accept()
        serviece_c()
    
## 6.单进程-单线程非堵塞版本http服务器

## 7.epoll/io复用
    原理：用事件通知，而不是轮询的方式来标记进程
               不用在应用程序和Linux内核中复制内存，是一种特殊的内存，直接使用。和应用程序之间共享内存
               可以标记进程，故知道是哪个可以收发的功能，直接通知应用程序