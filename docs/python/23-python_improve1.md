# python提高-1

## 1.GIL
    虚拟机-设置-处理器和内存

问题1：既然有GIL，那么为什么还会出现之前有2个线程各加100万，最后的结果不是200万的问题呢？
    GIL只是保证同一时刻只有一个线程在做，避免同一时刻没有多个线程执行，不能保证切换到下一个线程是彻彻底底地做完

问题2：既然GIL保证了同一时刻只有1个线程在运行，那么是否它的性能还不如单线程的性能高呢？
    特别是网络程序。

## 2.深拷贝和浅拷贝
    浅拷贝：仅仅是地址的拷贝，没有拷贝地址的内容；
    深拷贝：在copy的时候，如果是深拷贝那么就意味着递归copy，即如果被copy的列表中依然嵌套着列表，那么被嵌套的列表也会被copy；指向了一片新的内存空间 import copy c = copy.deepcopy(a)

注意点：
    列表的切片、字典copy完成的功能是浅拷贝 ；
    元祖的浅拷贝和深拷贝一层，全部指向同一个；元祖不可变是指元祖里的指向不可变；如果元祖里嵌套了一层列表，深拷贝会递归进行判断，如果有一个元素可变，那就递归拷贝
    如果copy的目标全部都是不可变类型，那么copy.copy和deep.copy功能一样，都是指向了那个不可变的数据空间
    
    import copy c = copy.copy(a)
    拷贝元祖时的特点：
    copy.copy()时，内存地址相同，因为元祖时不可变类型；
    使用copy模块的copy功能的时候，它会根据当前拷贝的数据类型是否是可变类型还是不可变类型有不同的处理方式

## 3.私有化
   __ 双前置下划线是私有属性，实例对象不能直接访问，可以通过设置get和set方法，在外部调用方法使用私有属性

name mangling名字重整_类名__私有属性
dir()

## 4.导入模块的搜索路径
    import sys
    sys.path

    增加路径：sys.path.append(“/home”)
    插入路径：sys.path.insert(0, “/home/itcast/xxx")

C语言：include “../xxx.h”
    from imp import reload 
    如果先把一个模块导入，将模块进行修改了，要将这个模块退出重新导入或者reload()就可以获取修改后的模块新内容

## 5.循环导入
    用主模块去导入各个独立的子模块
    
设计整个程序的顶层框架
搬瓦工 python+bug

## 6.面向对象的三大特性：封装、继承、多态
    调用的是对象的某个固定的方法。但是，如果这个对象在子类中重写了这个方法，那么就调用这个子类的方法；如果这个对象在子类中没有重写父类的方法，那么久调用父类的
调用的方法一样，但是根据

In [33]: a = [11, 22]
In [34]: b = [33, 44]
In [35]: c = [a, b]
In [36]: d = copy.copy(c)

In [37]: d
Out[37]: [[11, 22], [33, 44]]
In [38]: c
Out[38]: [[11, 22], [33, 44]]

In [39]: c.append([55])
In [40]: c
Out[40]: [[11, 22], [33, 44], [55]]
In [41]: d
Out[41]: [[11, 22], [33, 44]]

In [42]: c.append(66)
In [43]: c
Out[43]: [[11, 22], [33, 44], [55], 66]
In [44]: d
Out[44]: [[11, 22], [33, 44]]

In [45]: a.append(33)
In [46]: c
Out[46]: [[11, 22, 33], [33, 44], [55], 66]
In [47]: d
Out[47]: [[11, 22, 33], [33, 44]]

## 7. 请简述值传递和引用传递的区别？
值传递仅仅是传递的是值；
引用传递，传递的是内存地址，修改后会改变内存地址对应储存的值